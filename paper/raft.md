# raft

​	Raft是一个管理复制日志的共识算法。Raft的结果与经典共识算法Paxos一致，但Raft采用的结构与Paxos不同。Raft的结构更容易被理解，更易于构建实际应用。为了增强可理解性，Raft将共识要素分割成不同模块，有领导者选举、日志复制和安全。Raft采用强一致性保障，以减少需要考虑的状态数。研究结果表明Raft易于理解。Raft还提出来新的成员变更机制，以保证多数成员的安全。



# introduction

​	共识算法保障集群在部分机器故障时亦能正常工作。此类算法对于构建可靠的大规模软件系统至关重要。**Paxos** 是已被广泛讨论和使用经典共识算法。许多共识算法的实现都基于 Paxos 或受其影响。实际上，Paxos已成为向学生传授共识的主要方法。

​	然而**Paxos 难以理解和实现**，多次的简化尝试后但仍难以理解。 此外，Paxos的架构需要进行复杂的修改才能支持实际系统。使得系统构建者和学生都在使用 Paxos 时都存在困难。

​	因此需要创建一种比Paxos容易学习的算法，让系统构建者和学生更容易使用该算法。除了更易于学习外，清楚地了解该算法为何起作用对系统构建者至关重要。 通过提供对算法的直观理解，增强系统构建者有效使用和构建算法的能力。

​	本文提出了Raft共识算法。与Paxos等其他共识算法相比，Raft 通过分解和减少状态空间等特定技术来提高可理解性。分解例如领导者选举、日志复制和安全。对两所大学的43名学生的研究结果表明，Raft比Paxos更容易理解。在43名学生中，有33名能够更好地回答有关Raft的问题，而不是有关Paxos的问题。

​	Raft与现有共识算法有相似之处。但是，它还引入了一些新颖的功能：

- 强领导模式：在 Raft 中，日志条目只能从主服务器流向其他服务器，从而简化了对日志复制的管理，使 Raft 更易于理解。 
- 领导者选举：Raft 还使用**随机计时器**进行领导人选举。这种附加机制与共识算法所需的心跳相结合，有助于快速高效地解决冲突。
- ？成员变更管理？：Raft 在变更成员时使用**联合共识**方法，*<u>即在过渡期间，两种不同配置的大多数会重叠</u>*。这允许群集在配置更改期间继续正常运行。

​	无论是教育目的还是实际实现，Raft都优于Paxos和其他共识算法。 与其他算法相比，Raft 更简单、更易于理解，使学生和开发人员更容易学习和使用。 对Raft的描述足够详细，可以满足实际系统的需求，使其成为实施的合适基础。 Raft 有多个开源实现，并被多家公司使用，这表明其实际可行性。 Raft 的安全性能已得到正式规定和验证，确保了其可靠性。 Raft 的效率可与其他共识算法相媲美，使其成为实用系统的可行选择。



# 复制状态机

​	共识算法通常用于复制状态机的上下文。复制状态机涉及多台计算相同状态的相同副本的服务器。 即使某些服务器停机，状态机也可以继续运行。 复制状态机用于解决分布式系统中的容错问题。 例如，像 GFS、HDFS 和 RamCloud 这样的大型系统只有一个集群领导者，并使用副本状态机来管理领导者选举和存储配置信息。 复制状态机可确保配置信息在领导者崩溃后仍然存在。 复制状态机的示例包括 Chubby 和 ZooKeeper。

![image-20231119153133936](./images/raft/image-20231119153133936.png)

​	复制状态机通常使用复制日志来实现，如图1所示，这些日志顺序记录了操作命令。 每台服务器顺序执行日志中的命令，由于状态机是确定性的，相同的输入将始终产生相同的输出。 共识算法负责保持系统中所有服务器上复制的日志的一致性。

​	共识算法负责确保每台服务器的日志的一致性。 当客户端向服务器发送命令时，该服务器上的共识模块会将该命令添加到其日志中。 然后，共识模块将该命令复制到其他服务器中。 此复制过程可确保每台服务器的日志最终将以相同的顺序包含相同的命令。 正确复制命令后，每台服务器的状态机将按照日志中出现的顺序本地重放。 然后将状态机的输出返回给客户端。由于这个过程，服务器形成了一个单一的、高度可靠的状态机。

**使用复制的日志和共识算法的好处**

-使用复制的日志和共识算法，可以在多台服务器上创建高度可靠和一致的状态机。 -复制的日志确保每台服务器的状态机处理相同的命令序列，从而产生相同的状态和输出。 -共识算法可确保即使出现故障，复制的日志也能保持一致。 -这种方法为系统提供了容错能力和可靠性，因为即使某些服务器出现故障，状态机也可以继续运行。 -此外，使用复制的日志和共识算法简化了系统的实施和理解，使学生和研究人员更容易学习和使用。



​	用于实际系统的一致性算法通常具有以下特性：

- 保证在所有非拜占庭条件下的安全性(从不返回错误结果)，包括网络延迟、分区、分组丢失、复制和重新排序。
- 只要多数服务器正常（可以相互通信和与客户端通信），服务便可用。如五台服务器组成的集群可以承受任何两台服务器的故障。故障机器可通过存储的状态恢复并重新加入集群。
- 日志的一致性不依赖于时间：在最坏的情况下，错误的时钟和极端的消息延迟可能会导致可用性问题。
- 在常见情况下，只要大多数节点响应了RPC请求，命令就可以完成；少数速度较慢的服务器不会影响整体系统性能。（只要日志复制到大多数节点即认为变更生效）。



# Paxos的问题

​	在过去10年中，Paxos已经成为共识算法的标杆，其正确性已被各方认可。不幸的是，Paxos有两个重大的问题，其中之一是难以理解。对Paxos易理解性的工作集中在单一决策子集（single-decree subset）上，其分为两个阶段，但没有简单直观的解释，无法独立理解。Paxos的另一个问题是没有为构建实际应用提供良好的基础。其中一个原因是，目前还没有一个被广泛认可的multi-Paxos算法。Lamport的描述大多是关于单一决策的Paxos；他描述了实现multi-Paxos的可能方法，但许多细节都缺失了。许多关于Paxos的优化实现都彼此不同，也不同于Lamport的草图。如Chubby实现了类似Paxos的算法，但在大多数情况下，它们的细节还没有公布。

​	此外，Paxos架构对于构建实用系统来说是一个糟糕的架构；这是单一决策分解的另一个后果。例如，单独选择一组日志条目，然后将它们合并到一个顺序日志中只会增加复杂性。其中新条目以受约束的顺序追加会让日志系统更简单更高效。另一个问题是，Paxos在其核心使用了一种对称的点对点方法(尽管它最终提出了一种软弱的领导形式，以实现绩效优化)。这在简单决策（如单一命令的简化世界）中是有意义的，但很少有实际系统使用这种方法。而在系列决策中，先选举领导人，然后让领导人协调决策，会更简单、更快。

​	因此，实用的系统与Paxos几乎没有相似之处。从Paxos开始，在遇到困难后开发出一个显著不同的体系结构。这既耗时又容易出错，而且Paxos的难以理解加剧了问题。Paxos的公式可能是证明关于其正确性的定理的一个很好的公式，但真正的实现与Paxos是如此不同，以至于证明没有什么价值。来自Chubby实施者的以下评论是典型的：在对Paxos算法的描述与实际系统的需求之间有很大的差距...最终的系统将基于未经证实的协议实现。

​	综上，Paxos 并没有为系统构建或教育提供良好的基础。鉴于共识在大型软件系统中的重要性，我们决定看看是否可以设计一种比 Paxos 具有更好性能的替代共识算法。 Raft 因此诞生。



# 易理解的设计

​	设计Raft有几个目标：它必须为系统构建提供完整且实用的基础，从而大大减少开发人员的工作量；它必须在所有条件下都是安全的，并且在经典操作下可用；并且对于常见的操作必须是高效的。但我们最重要的目标——也是最困难的挑战——是可理解性。必须能够让大量受众轻松地理解该算法。此外，必须能够发展对算法的直觉，以便系统构建者可以进行现实世界实现中不可避免的扩展。

​	设计Raft有几个目标：为系统构建提供完整而实用的基础，减少开发人员的设计工作量；确保算法在所有条件下的安全性及其在典型操作条件下的可用性，并提高常见操作的效率；但是，最重要和最具挑战性的目标是让广大受众能够理解该算法；此外，设计人员希望系统构建者能透过直觉够理解算法的基本原理，并在实际实现中进行必要的扩展。

​	在Raft的设计过程中，设计师根据其可理解性对候选方案进行了评估。考虑了理解方案的有多难，如状态空间的复杂性及其可能产生的影响。此外，还评估了读者完全理解所选方法及其含义有多容易。设计人员优先考虑可理解性，以确保算法易于理解并可以向广大受众解释。

​	对共识算法的分析可能是主观的，因此使用了两种技术来使分析更加客观。第一种技术是**问题分解**，将复杂的问题分解成更小、更易于管理的部分。以 Raft 为例，将共识问题分领导者选举、日志复制、安全和成员变更。以此独立地求解、解释和理解每个组件，这使得整个算法更容易理解。

​	第二种方法是**简化算法的状态空间**（系统在任何给定时间可能处于的所有状态）。通过减少需要考虑的状态数量，消除了不必要的复杂性，使系统更加协调一致。例如，在 Raft 中，日志不允许有间隙，并限制了可能导致日志不一致的行为。状态空间的简化使算法更容易推理，并减少了出现意外行为的几率。此外，在大多数情况下，不确定性使算法更难理解。但是，在某些情况下，引入一定程度的不确定性实际上可以提高可理解性。其中一种情况是 Raft 领导者选举算法，随机化引入了不确定性，但它通过以类似的方式处理所有可能的选择来缩小状态空间，从而更容易推理算法。



# Raft算法

​	Raft 是一种旨在管理复制日志的算法，该日志记录需要在多个服务器上复制的事件或操作。本文第 2 节描述了该算法，图 2 提供了算法的简要摘要，便于参考。图 3 列出了算法的关键属性，本节的其余部分将详细讨论这些内容。

![raft-state.drawio](./images/raft/raft-state.drawio.png)

​	Raft 通过选举领导者来实现共识，领导者负责管理复制日志。领导者从客户端接收日志条目，将其复制到其他服务器上，并在日志条目应用到其状态机时ACK。领导者可以简化复制日志的管理，因为领导者可以在不咨询其他服务器的情况下决定在哪里放置新条目。数据以直接的方式从领导者流向其他服务器。但是，领导者可能会失败或与其他服务器断开连接，在这种情况下，需要选出新的领导者。

​	Raft 将共识问题分解为三个相对独立的子问题：领导者选举、日志复制和安全：

-   领导人选举涉及在现有领导人失败时选择新的领导人。

-   日志复制是领导者接受日志条目并将其复制到其他服务器的过程。

-   Raft 中的安全属性是共识算法的关键方面，可确保复制日志的完整性和一致性。如图 3 所示，一旦服务器执行了来自特定日志条目的命令，则禁止任何其他服务器对该日志条目执行不同的命令。本文的第5.4节描述了Raft如何确保状态机器安全属性。保障这种安全属性的解决方案涉及对选举机制的额外限制，将在5.2节进行解释。

​	在介绍共识算法之后，剩余部分将深入探讨了可用性问题以及计时在 Raft 系统中的作用。



## Raft基础



## 领导者选举



## 日志复制



## 安全



### 选举限制



### 日志条目提交



### 安全参数



## 跟随者及候选者失败



## 时效及可用性





# 成员管理



# 日志压缩



# 客户端交互



